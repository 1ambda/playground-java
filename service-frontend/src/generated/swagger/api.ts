/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Gateway
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface CartDTO
 */
export interface CartDTO {
    /**
     * 
     * @type {number}
     * @memberof CartDTO
     */
    cartId?: number;
    /**
     * 
     * @type {number}
     * @memberof CartDTO
     */
    updatedAt?: number;
    /**
     * 
     * @type {number}
     * @memberof CartDTO
     */
    totalPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof CartDTO
     */
    itemCount?: number;
    /**
     * 
     * @type {Array&lt;CartLineDTO&gt;}
     * @memberof CartDTO
     */
    cartLines?: Array<CartLineDTO>;
}

/**
 * 
 * @export
 * @interface CartLineDTO
 */
export interface CartLineDTO {
    /**
     * 
     * @type {number}
     * @memberof CartLineDTO
     */
    cartLineID?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineDTO
     */
    createdAt?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineDTO
     */
    updatedAt?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineDTO
     */
    totalPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineDTO
     */
    index?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineDTO
     */
    quantity?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineDTO
     */
    productPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineDTO
     */
    productId?: number;
    /**
     * 
     * @type {Array&lt;CartLineOptionDTO&gt;}
     * @memberof CartLineDTO
     */
    cartLineOptions?: Array<CartLineOptionDTO>;
}

/**
 * 
 * @export
 * @interface CartLineOptionDTO
 */
export interface CartLineOptionDTO {
    /**
     * 
     * @type {number}
     * @memberof CartLineOptionDTO
     */
    cartLineOptionId?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineOptionDTO
     */
    updatedAt?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineOptionDTO
     */
    createdAt?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineOptionDTO
     */
    quantity?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineOptionDTO
     */
    productOptionId?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineOptionDTO
     */
    productOptionPrice?: number;
}

/**
 * 
 * @export
 * @interface CartLineOptionRequestDTO
 */
export interface CartLineOptionRequestDTO {
    /**
     * might be null depending on the request type
     * @type {number}
     * @memberof CartLineOptionRequestDTO
     */
    cartLineOptionId?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineOptionRequestDTO
     */
    productOptionId?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineOptionRequestDTO
     */
    quantity?: number;
}

/**
 * 
 * @export
 * @interface CartLineRequestDTO
 */
export interface CartLineRequestDTO {
    /**
     * might be null depending on the request type
     * @type {number}
     * @memberof CartLineRequestDTO
     */
    cartLineId?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineRequestDTO
     */
    productId?: number;
    /**
     * 
     * @type {number}
     * @memberof CartLineRequestDTO
     */
    quantity?: number;
    /**
     * 
     * @type {Array&lt;CartLineOptionRequestDTO&gt;}
     * @memberof CartLineRequestDTO
     */
    options?: Array<CartLineOptionRequestDTO>;
}

/**
 * 
 * @export
 * @interface CategoryDTO
 */
export interface CategoryDTO {
    /**
     * 
     * @type {number}
     * @memberof CategoryDTO
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CategoryDTO
     */
    parentCategoryId?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDTO
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDTO
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDTO
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface CategoryListDTO
 */
export interface CategoryListDTO {
    /**
     * 
     * @type {Array&lt;CategoryDTO&gt;}
     * @memberof CategoryListDTO
     */
    items?: Array<CategoryDTO>;
}

/**
 * 
 * @export
 * @interface Failure
 */
export interface Failure {
    /**
     * 
     * @type {number}
     * @memberof Failure
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof Failure
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof Failure
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof Failure
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Failure
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof Failure
     */
    stacktrace?: string;
}

/**
 * 
 * @export
 * @interface PaginatedProductDTO
 */
export interface PaginatedProductDTO {
    /**
     * 
     * @type {Array&lt;ProductContainerDTO&gt;}
     * @memberof PaginatedProductDTO
     */
    products?: Array<ProductContainerDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof PaginatedProductDTO
     */
    pagination?: Pagination;
}

/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    itemCountPerPage: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    currentPageOffset: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    totalItemCount: number;
}

/**
 * 
 * @export
 * @interface ProductContainerDTO
 */
export interface ProductContainerDTO {
    /**
     * 
     * @type {ProductDTO}
     * @memberof ProductContainerDTO
     */
    item?: ProductDTO;
    /**
     * 
     * @type {Array&lt;ProductOptionDTO&gt;}
     * @memberof ProductContainerDTO
     */
    options?: Array<ProductOptionDTO>;
}

/**
 * 
 * @export
 * @interface ProductDTO
 */
export interface ProductDTO {
    /**
     * 
     * @type {number}
     * @memberof ProductDTO
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDTO
     */
    createdAt?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDTO
     */
    updatedAt?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDTO
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDTO
     */
    price?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDTO
     */
    onSale?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDTO
     */
    categoryId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDTO
     */
    categoryDisplayName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDTO
     */
    categoryPath?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDTO
     */
    imageId?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDTO
     */
    imageType?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDTO
     */
    imagePath?: string;
}

/**
 * 
 * @export
 * @interface ProductOptionDTO
 */
export interface ProductOptionDTO {
    /**
     * 
     * @type {number}
     * @memberof ProductOptionDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductOptionDTO
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductOptionDTO
     */
    price?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductOptionDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductOptionDTO
     */
    onSale?: string;
}

/**
 * 
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    address?: string;
    /**
     * 
     * @type {Array&lt;string&gt;}
     * @memberof UserDTO
     */
    roles?: Array<string>;
}


/**
 * AuthControllerApi - fetch parameter creator
 * @export
 */
export const AuthControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(options: any = {}): FetchArgs {
            const localVarPath = `/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options: any = {}): FetchArgs {
            const localVarPath = `/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: UserDTO, options: any = {}): FetchArgs {
            const localVarPath = `/auth/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoiam(options: any = {}): FetchArgs {
            const localVarPath = `/auth/whoiam`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDTO> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).login(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).logout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UserDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: UserDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDTO> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).register(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoiam(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDTO> {
            const localVarFetchArgs = AuthControllerApiFetchParamCreator(configuration).whoiam(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(options?: any) {
            return AuthControllerApiFp(configuration).login(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any) {
            return AuthControllerApiFp(configuration).logout(options)(fetch, basePath);
        },
        /**
         * 
         * @param {UserDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body?: UserDTO, options?: any) {
            return AuthControllerApiFp(configuration).register(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoiam(options?: any) {
            return AuthControllerApiFp(configuration).whoiam(options)(fetch, basePath);
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public login(options?: any) {
        return AuthControllerApiFp(this.configuration).login(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public logout(options?: any) {
        return AuthControllerApiFp(this.configuration).logout(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public register(body?: UserDTO, options?: any) {
        return AuthControllerApiFp(this.configuration).register(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public whoiam(options?: any) {
        return AuthControllerApiFp(this.configuration).whoiam(options)(this.fetch, this.basePath);
    }

}

/**
 * CartControllerApi - fetch parameter creator
 * @export
 */
export const CartControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CartLineDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCartLine(body?: CartLineDTO, options: any = {}): FetchArgs {
            const localVarPath = `/cart/user/lines`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartLineDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUserCartLines(options: any = {}): FetchArgs {
            const localVarPath = `/cart/user/lines`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCartLines(options: any = {}): FetchArgs {
            const localVarPath = `/cart/user/lines`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserCartLine(lineId: number, options: any = {}): FetchArgs {
            // verify required parameter 'lineId' is not null or undefined
            if (lineId === null || lineId === undefined) {
                throw new RequiredError('lineId','Required parameter lineId was null or undefined when calling removeUserCartLine.');
            }
            const localVarPath = `/cart/user/line/{lineId}`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} lineId 
         * @param {number} optionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserCartLineOption(lineId: number, optionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'lineId' is not null or undefined
            if (lineId === null || lineId === undefined) {
                throw new RequiredError('lineId','Required parameter lineId was null or undefined when calling removeUserCartLineOption.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling removeUserCartLineOption.');
            }
            const localVarPath = `/cart/user/line/{lineId}/option/{optionId}`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} lineId 
         * @param {CartLineRequestDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCartLine(lineId: number, body?: CartLineRequestDTO, options: any = {}): FetchArgs {
            // verify required parameter 'lineId' is not null or undefined
            if (lineId === null || lineId === undefined) {
                throw new RequiredError('lineId','Required parameter lineId was null or undefined when calling updateUserCartLine.');
            }
            const localVarPath = `/cart/user/line/{lineId}`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartLineRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} lineId 
         * @param {number} optionId 
         * @param {CartLineOptionRequestDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCartLineOption(lineId: number, optionId: number, body?: CartLineOptionRequestDTO, options: any = {}): FetchArgs {
            // verify required parameter 'lineId' is not null or undefined
            if (lineId === null || lineId === undefined) {
                throw new RequiredError('lineId','Required parameter lineId was null or undefined when calling updateUserCartLineOption.');
            }
            // verify required parameter 'optionId' is not null or undefined
            if (optionId === null || optionId === undefined) {
                throw new RequiredError('optionId','Required parameter optionId was null or undefined when calling updateUserCartLineOption.');
            }
            const localVarPath = `/cart/user/line/{lineId}/option/{optionId}`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)))
                .replace(`{${"optionId"}}`, encodeURIComponent(String(optionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CartLineOptionRequestDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartControllerApi - functional programming interface
 * @export
 */
export const CartControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CartLineDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCartLine(body?: CartLineDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartLineDTO> {
            const localVarFetchArgs = CartControllerApiFetchParamCreator(configuration).addUserCartLine(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUserCartLines(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CartControllerApiFetchParamCreator(configuration).clearUserCartLines(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCartLines(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartDTO> {
            const localVarFetchArgs = CartControllerApiFetchParamCreator(configuration).getUserCartLines(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserCartLine(lineId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CartControllerApiFetchParamCreator(configuration).removeUserCartLine(lineId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} lineId 
         * @param {number} optionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserCartLineOption(lineId: number, optionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CartControllerApiFetchParamCreator(configuration).removeUserCartLineOption(lineId, optionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} lineId 
         * @param {CartLineRequestDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCartLine(lineId: number, body?: CartLineRequestDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartLineDTO> {
            const localVarFetchArgs = CartControllerApiFetchParamCreator(configuration).updateUserCartLine(lineId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} lineId 
         * @param {number} optionId 
         * @param {CartLineOptionRequestDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCartLineOption(lineId: number, optionId: number, body?: CartLineOptionRequestDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartLineOptionDTO> {
            const localVarFetchArgs = CartControllerApiFetchParamCreator(configuration).updateUserCartLineOption(lineId, optionId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CartControllerApi - factory interface
 * @export
 */
export const CartControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CartLineDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCartLine(body?: CartLineDTO, options?: any) {
            return CartControllerApiFp(configuration).addUserCartLine(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearUserCartLines(options?: any) {
            return CartControllerApiFp(configuration).clearUserCartLines(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCartLines(options?: any) {
            return CartControllerApiFp(configuration).getUserCartLines(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} lineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserCartLine(lineId: number, options?: any) {
            return CartControllerApiFp(configuration).removeUserCartLine(lineId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} lineId 
         * @param {number} optionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserCartLineOption(lineId: number, optionId: number, options?: any) {
            return CartControllerApiFp(configuration).removeUserCartLineOption(lineId, optionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} lineId 
         * @param {CartLineRequestDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCartLine(lineId: number, body?: CartLineRequestDTO, options?: any) {
            return CartControllerApiFp(configuration).updateUserCartLine(lineId, body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} lineId 
         * @param {number} optionId 
         * @param {CartLineOptionRequestDTO} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCartLineOption(lineId: number, optionId: number, body?: CartLineOptionRequestDTO, options?: any) {
            return CartControllerApiFp(configuration).updateUserCartLineOption(lineId, optionId, body, options)(fetch, basePath);
        },
    };
};

/**
 * CartControllerApi - object-oriented interface
 * @export
 * @class CartControllerApi
 * @extends {BaseAPI}
 */
export class CartControllerApi extends BaseAPI {
    /**
     * 
     * @param {} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartControllerApi
     */
    public addUserCartLine(body?: CartLineDTO, options?: any) {
        return CartControllerApiFp(this.configuration).addUserCartLine(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartControllerApi
     */
    public clearUserCartLines(options?: any) {
        return CartControllerApiFp(this.configuration).clearUserCartLines(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartControllerApi
     */
    public getUserCartLines(options?: any) {
        return CartControllerApiFp(this.configuration).getUserCartLines(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} lineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartControllerApi
     */
    public removeUserCartLine(lineId: number, options?: any) {
        return CartControllerApiFp(this.configuration).removeUserCartLine(lineId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} lineId 
     * @param {} optionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartControllerApi
     */
    public removeUserCartLineOption(lineId: number, optionId: number, options?: any) {
        return CartControllerApiFp(this.configuration).removeUserCartLineOption(lineId, optionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} lineId 
     * @param {} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartControllerApi
     */
    public updateUserCartLine(lineId: number, body?: CartLineRequestDTO, options?: any) {
        return CartControllerApiFp(this.configuration).updateUserCartLine(lineId, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} lineId 
     * @param {} optionId 
     * @param {} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartControllerApi
     */
    public updateUserCartLineOption(lineId: number, optionId: number, body?: CartLineOptionRequestDTO, options?: any) {
        return CartControllerApiFp(this.configuration).updateUserCartLineOption(lineId, optionId, body, options)(this.fetch, this.basePath);
    }

}

/**
 * CatalogControllerApi - fetch parameter creator
 * @export
 */
export const CatalogControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCategories(options: any = {}): FetchArgs {
            const localVarPath = `/catalog/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProduct(productId: number, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling findOneProduct.');
            }
            const localVarPath = `/catalog/product/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaginatedProducts(page?: number, count?: number, options: any = {}): FetchArgs {
            const localVarPath = `/catalog/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogControllerApi - functional programming interface
 * @export
 */
export const CatalogControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCategories(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryListDTO> {
            const localVarFetchArgs = CatalogControllerApiFetchParamCreator(configuration).findAllCategories(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProduct(productId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductDTO> {
            const localVarFetchArgs = CatalogControllerApiFetchParamCreator(configuration).findOneProduct(productId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaginatedProducts(page?: number, count?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaginatedProductDTO> {
            const localVarFetchArgs = CatalogControllerApiFetchParamCreator(configuration).findPaginatedProducts(page, count, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CatalogControllerApi - factory interface
 * @export
 */
export const CatalogControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCategories(options?: any) {
            return CatalogControllerApiFp(configuration).findAllCategories(options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProduct(productId: number, options?: any) {
            return CatalogControllerApiFp(configuration).findOneProduct(productId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [count] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaginatedProducts(page?: number, count?: number, options?: any) {
            return CatalogControllerApiFp(configuration).findPaginatedProducts(page, count, options)(fetch, basePath);
        },
    };
};

/**
 * CatalogControllerApi - object-oriented interface
 * @export
 * @class CatalogControllerApi
 * @extends {BaseAPI}
 */
export class CatalogControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogControllerApi
     */
    public findAllCategories(options?: any) {
        return CatalogControllerApiFp(this.configuration).findAllCategories(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogControllerApi
     */
    public findOneProduct(productId: number, options?: any) {
        return CatalogControllerApiFp(this.configuration).findOneProduct(productId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {} [page] 
     * @param {} [count] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogControllerApi
     */
    public findPaginatedProducts(page?: number, count?: number, options?: any) {
        return CatalogControllerApiFp(this.configuration).findPaginatedProducts(page, count, options)(this.fetch, this.basePath);
    }

}

